//! Integration test: verify `--legacy` conversion against C++ reference VTK files.
//!
//! This is the Rust equivalent of `tests/run.sh`.  For every OpenRadioss
//! animation file in `tests/`, the converter binary is invoked with
//! `--legacy` and the output is compared (whitespace-insensitive) against
//! the corresponding `ref_<name>.vtk` reference file generated by the
//! C++ converter (`anim_to_vtk_linux64_gf`).

use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Directory containing both the animation input files and the `.vtk`
/// reference files.
fn test_data_dir() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("tests")
}

/// Return the path to the built binary.
fn binary_path() -> PathBuf {
    // `cargo test` puts the binary in the same target directory
    let mut path = std::env::current_exe()
        .expect("cannot determine test executable path");
    // Go up from  target/<profile>/deps/<test_binary>  to  target/<profile>/
    path.pop(); // remove test binary name
    if path.ends_with("deps") {
        path.pop(); // remove "deps"
    }
    path.push("anim_to_vtk");
    path
}

/// Collect all animation input files in the test-data directory.
///
/// An animation file is any file whose name does **not** contain a dot
/// (no extension) and matches the OpenRadioss naming convention
/// (ends with an uppercase letter followed by digits).
fn collect_anim_files(dir: &Path) -> Vec<PathBuf> {
    let mut files: Vec<PathBuf> = fs::read_dir(dir)
        .expect("cannot read test data directory")
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let path = entry.path();
            if !path.is_file() {
                return None;
            }
            let name = path.file_name()?.to_str()?;
            // Skip files with extensions (.vtk, .sh, .rs, …) and other
            // non-animation artefacts.
            if name.contains('.') || name.starts_with("ref_") {
                return None;
            }
            // Must match the A-file pattern: ends with letter + digits
            if !name.chars().last().map_or(false, |c| c.is_ascii_digit()) {
                return None;
            }
            Some(path)
        })
        .collect();
    files.sort();
    files
}

/// Compare two VTK files token-by-token with numeric tolerance.
///
/// Non-numeric tokens (headers, keywords) must match exactly.
/// Numeric tokens are compared with tolerance: integers must match
/// exactly, floats allow a relative tolerance of 5e-6 (absorbs
/// last-digit rounding differences between C++ `printf` and Rust).
fn vtk_files_match(actual: &str, expected: &str) -> Option<String> {
    let mut a_tokens = actual.split_whitespace();
    let mut b_tokens = expected.split_whitespace();
    let mut token_idx = 0usize;

    loop {
        match (a_tokens.next(), b_tokens.next()) {
            (Some(a), Some(b)) => {
                if a != b {
                    // Both integers? Must match exactly.
                    if let (Ok(ia), Ok(ib)) = (a.parse::<i64>(), b.parse::<i64>()) {
                        return Some(format!(
                            "token {}: integer mismatch: got {} vs ref {}",
                            token_idx, ia, ib
                        ));
                    }
                    // Try float comparison with tolerance
                    match (a.parse::<f64>(), b.parse::<f64>()) {
                        (Ok(va), Ok(vb)) => {
                            if !approx_eq(va, vb) {
                                return Some(format!(
                                    "token {}: got '{}' ({}) vs ref '{}' ({})",
                                    token_idx, a, va, b, vb
                                ));
                            }
                        }
                        _ => {
                            return Some(format!(
                                "token {}: got '{}' vs ref '{}'",
                                token_idx, a, b
                            ));
                        }
                    }
                }
                token_idx += 1;
            }
            (None, None) => return None, // both exhausted, files match
            (Some(a), None) => {
                return Some(format!("extra token at position {}: '{}'", token_idx, a));
            }
            (None, Some(b)) => {
                return Some(format!("missing token at position {} (ref has '{}')", token_idx, b));
            }
        }
    }
}

/// Compare two f64 values with relative tolerance suitable for 6
/// significant digits, also handling zero and near-zero values.
fn approx_eq(a: f64, b: f64) -> bool {
    if a == b {
        return true;
    }
    let diff = (a - b).abs();
    let max = a.abs().max(b.abs());
    if max == 0.0 {
        return diff == 0.0;
    }
    diff / max < 5e-6
}

#[test]
fn legacy_conversion_matches_reference() {
    let data_dir = test_data_dir();
    let bin = binary_path();
    assert!(
        bin.exists(),
        "binary not found at {:?} – run `cargo build` first",
        bin
    );

    let anim_files = collect_anim_files(&data_dir);
    assert!(
        !anim_files.is_empty(),
        "no animation files found in {:?}",
        data_dir
    );

    // Use a temporary directory for the converter output so that we
    // never overwrite the reference files.
    let tmp_dir = tempfile::tempdir().expect("cannot create temp dir");

    let mut failures: Vec<String> = Vec::new();

    for anim_path in &anim_files {
        let anim_name = anim_path
            .file_name()
            .unwrap()
            .to_str()
            .unwrap();

        // Copy the animation file into the temp dir (the converter
        // writes <input>.vtk next to the input file).
        let tmp_input = tmp_dir.path().join(anim_name);
        fs::copy(anim_path, &tmp_input).unwrap_or_else(|e| {
            panic!("cannot copy {:?} to {:?}: {}", anim_path, tmp_input, e);
        });

        // Run the converter
        let output = Command::new(&bin)
            .arg(&tmp_input)
            .arg("--legacy")
            .output()
            .unwrap_or_else(|e| {
                panic!("failed to run {:?}: {}", bin, e);
            });

        if !output.status.success() {
            failures.push(format!(
                "{}: converter exited with status {} – stderr: {}",
                anim_name,
                output.status,
                String::from_utf8_lossy(&output.stderr),
            ));
            continue;
        }

        // Read the converter output
        let vtk_output_path = tmp_dir
            .path()
            .join(format!("{}.vtk", anim_name));
        let got = match fs::read_to_string(&vtk_output_path) {
            Ok(s) => s,
            Err(e) => {
                failures.push(format!(
                    "{}: cannot read output {:?}: {}",
                    anim_name, vtk_output_path, e
                ));
                continue;
            }
        };

        // Read the C++ reference file (ref_<name>.vtk, generated by run.sh)
        let ref_path = data_dir.join(format!("ref_{}.vtk", anim_name));
        let expected = match fs::read_to_string(&ref_path) {
            Ok(s) => s,
            Err(e) => {
                failures.push(format!(
                    "{}: cannot read reference {:?}: {}",
                    anim_name, ref_path, e
                ));
                continue;
            }
        };

        // Compare with numeric tolerance (absorbs last-digit rounding diffs)
        if let Some(diff) = vtk_files_match(&got, &expected) {
            failures.push(format!(
                "{}: {}", anim_name, diff
            ));
        }
    }

    if !failures.is_empty() {
        let msg = format!(
            "\n{} / {} files failed:\n  - {}",
            failures.len(),
            anim_files.len(),
            failures.join("\n  - ")
        );
        panic!("{}", msg);
    }

    eprintln!(
        "All {} legacy conversions match their references.",
        anim_files.len()
    );
}
